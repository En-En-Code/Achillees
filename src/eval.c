#include "board.h"


/*
 * Evaluates a position which has no possible moves.
 * Returns 1 on checkmate and 0 on stalemate.
 */
int finalEval(Board board, const int depth) {
	const int color = board.turn;
	int result;

	if (kingInCheck(board, board.pieces[color][KING], color)) {
		result = -10000 - depth;
	} else {
		result = 0;
	}

	return result;
}

int eval(Board board) {
	const int color = board.turn, opColor = 1 - color;

	int x = 9 * (popCount(board.pieces[color][QUEEN])  - popCount(board.pieces[opColor][QUEEN]))  +
			5 * (popCount(board.pieces[color][ROOK])   - popCount(board.pieces[opColor][ROOK]))   +
			3 * (popCount(board.pieces[color][BISHOP]) - popCount(board.pieces[opColor][BISHOP])) +
			3 * (popCount(board.pieces[color][KNIGHT]) - popCount(board.pieces[opColor][KNIGHT])) +
			1 * (popCount(board.pieces[color][PAWN])   - popCount(board.pieces[opColor][PAWN]));

	return x;
}

/*
int doubledPawns(uint64_t bb) {
	static const uint64_t doubledPawnsLookup[120] = {
			0x10100, 0x20200, 0x40400, 0x80800, 0x101000, 0x202000, 0x404000, 0x808000, 0x1000100, 0x1010000, 0x2000200, 0x2020000, 0x4000400, 0x4040000, 0x8000800, 0x8080000, 0x10001000, 0x10100000, 0x20002000, 0x20200000, 0x40004000, 0x40400000, 0x80008000, 0x80800000, 0x100000100, 0x100010000, 0x101000000, 0x200000200, 0x200020000, 0x202000000, 0x400000400, 0x400040000, 0x404000000, 0x800000800, 0x800080000, 0x808000000, 0x1000001000, 0x1000100000, 0x1010000000, 0x2000002000, 0x2000200000, 0x2020000000, 0x4000004000, 0x4000400000, 0x4040000000, 0x8000008000, 0x8000800000, 0x8080000000, 0x10000000100, 0x10000010000, 0x10001000000, 0x10100000000, 0x20000000200, 0x20000020000, 0x20002000000, 0x20200000000, 0x40000000400, 0x40000040000, 0x40004000000, 0x40400000000, 0x80000000800, 0x80000080000, 0x80008000000, 0x80800000000, 0x100000001000, 0x100000100000, 0x100010000000, 0x101000000000, 0x200000002000, 0x200000200000, 0x200020000000, 0x202000000000, 0x400000004000, 0x400000400000, 0x400040000000, 0x404000000000, 0x800000008000, 0x800000800000, 0x800080000000, 0x808000000000, 0x1000000000100, 0x1000000010000, 0x1000001000000, 0x1000100000000, 0x1010000000000, 0x2000000000200, 0x2000000020000, 0x2000002000000, 0x2000200000000, 0x2020000000000, 0x4000000000400, 0x4000000040000, 0x4000004000000, 0x4000400000000, 0x4040000000000, 0x8000000000800, 0x8000000080000, 0x8000008000000, 0x8000800000000, 0x8080000000000, 0x10000000001000, 0x10000000100000, 0x10000010000000, 0x10001000000000, 0x10100000000000, 0x20000000002000, 0x20000000200000, 0x20000020000000, 0x20002000000000, 0x20200000000000, 0x40000000004000, 0x40000000400000, 0x40000040000000, 0x40004000000000, 0x40400000000000, 0x80000000008000, 0x80000000800000, 0x80000080000000, 0x80008000000000, 0x80800000000000
	};

	int count = 0;

	for (int i = 0; i < 120; i++) {
		if (bb & doubledPawnsLookup[i]) ++count;
	}

	return count;
}

int isolatedPawns(uint64_t bb) {
	static const uint64_t neighborPawns[8] = {
			0x2020202020200, 0x5050505050500, 0xa0a0a0a0a0a00, 0x14141414141400, 0x28282828282800, 0x50505050505000, 0xa0a0a0a0a0a000, 0x40404040404000
	};

	int pawn, count = 0;
	uint64_t aux = bb;

	if (bb) do {
		pawn = bitScanForward(aux);

		if ((neighborPawns[get_col(pawn)] & bb) == 0) ++count;
	} while (unsetLSB(aux));

	return count;
}
*/
